# Dependency Injection Best Practices

## 1. Constructor Injection

### ✅ DO: Use constructor injection

```java
// DO: Constructor injection (preferred)
@Service
@RequiredArgsConstructor  // Lombok generates constructor
public class OrderService {
    private final OrderRepository repository;
    private final PaymentService paymentService;
    private final NotificationService notificationService;
    
    // Constructor auto-generated by Lombok
    // public OrderService(OrderRepository repository, 
    //                     PaymentService paymentService,
    //                     NotificationService notificationService) {
    //     this.repository = repository;
    //     this.paymentService = paymentService;
    //     this.notificationService = notificationService;
    // }
    
    public Order createOrder(OrderDto dto) {
        Order order = repository.save(dto.toEntity());
        paymentService.processPayment(order);
        notificationService.sendConfirmation(order);
        return order;
    }
}

// DO: Manual constructor injection (when not using Lombok)
@Service
public class UserService {
    private final UserRepository repository;
    private final PasswordEncoder passwordEncoder;
    
    public UserService(UserRepository repository, PasswordEncoder passwordEncoder) {
        this.repository = repository;
        this.passwordEncoder = passwordEncoder;
    }
}

// DO: Constructor injection with validation
@Service
public class ProductService {
    private final ProductRepository repository;
    private final ProductValidator validator;
    
    public ProductService(ProductRepository repository, ProductValidator validator) {
        this.repository = Objects.requireNonNull(repository, "Repository required");
        this.validator = Objects.requireNonNull(validator, "Validator required");
    }
}
```

**When to use:** Always. Constructor injection is the recommended approach in Spring.

**Benefits:**
- Immutability (final fields)
- Easier testing (just pass dependencies)
- Makes dependencies explicit
- Prevents NullPointerException
- Circular dependencies detected at startup

**When NOT to use:** Never avoid constructor injection for field/setter injection in services.

### ❌ DON'T: Use field injection

```java
// DON'T: Field injection
@Service
public class OrderService {
    @Autowired  // Don't do this
    private OrderRepository repository;
    
    @Autowired  // Don't do this
    private PaymentService paymentService;
    
    public Order createOrder(OrderDto dto) {
        // Dependencies can be null if injection fails
        return repository.save(dto.toEntity());
    }
}

// Problems:
// 1. Cannot make fields final - mutability
// 2. Hard to test (need Spring context or reflection)
// 3. Hidden dependencies (not visible in constructor)
// 4. NullPointerException risk
// 5. Circular dependencies not detected early

// DON'T: Setter injection for required dependencies
@Service
public class UserService {
    private UserRepository repository;
    
    @Autowired  // Don't use for required dependencies
    public void setRepository(UserRepository repository) {
        this.repository = repository;
    }
}
```

**When this appears:** Old Spring patterns, tutorials from Spring 3.x era.

**Why it's wrong:** Testing difficulty, mutability, hidden dependencies, potential NPE.

---

## 2. Bean Scopes

### ✅ DO: Use appropriate bean scopes

```java
// DO: Singleton (default) for stateless services
@Service  // Singleton by default
public class UserService {
    private final UserRepository repository;  // Shared state OK (injected dependencies)
    
    public UserService(UserRepository repository) {
        this.repository = repository;
    }
}

// DO: Prototype for stateful beans
@Component
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public class ShoppingCart {
    private final List<CartItem> items = new ArrayList<>();  // Stateful
    
    public void addItem(CartItem item) {
        items.add(item);
    }
}

// DO: Request scope for web request data
@Component
@RequestScope  // or @Scope(WebApplicationContext.SCOPE_REQUEST)
public class RequestContext {
    private String traceId;
    private String userId;
    
    public void initialize(HttpServletRequest request) {
        this.traceId = request.getHeader("X-Trace-Id");
        this.userId = extractUserId(request);
    }
}

// DO: Session scope for user session data
@Component
@SessionScope
public class UserSession {
    private String sessionId;
    private User currentUser;
    private ZonedDateTime loginTime;
}

// DO: Application scope for truly global state
@Component
@ApplicationScope
public class ApplicationStatistics {
    private final AtomicLong totalRequests = new AtomicLong(0);
    private final AtomicLong totalErrors = new AtomicLong(0);
    
    public void incrementRequests() {
        totalRequests.incrementAndGet();
    }
}
```

**When to use:**
- **Singleton** (default): Stateless services, repositories, configurations (99% of beans)
- **Prototype**: Stateful objects that shouldn't be shared (rare)
- **Request**: Web request-specific data
- **Session**: User session data
- **Application**: Global shared state (rare, consider cache instead)

**When NOT to use:** Non-default scopes unless you have a specific reason.

### ❌ DON'T: Misuse bean scopes

```java
// DON'T: Stateful singleton beans
@Service  // Singleton - shared across all requests!
public class OrderService {
    private Order currentOrder;  // WRONG - shared mutable state!
    
    public void processOrder(Order order) {
        this.currentOrder = order;  // Race condition in concurrent requests
        // Process...
    }
}

// Better: Pass as parameter or use request scope
@Service
public class OrderService {
    public void processOrder(Order order) {  // Parameter - no shared state
        // Process order
    }
}

// DON'T: Prototype scope for stateless beans
@Service
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)  // Unnecessary
public class UserService {
    private final UserRepository repository;  // Stateless
    
    // No instance variables - doesn't need prototype scope!
}

// Better: Use default singleton
@Service
public class UserService {
    private final UserRepository repository;
}

// DON'T: Inject shorter-lived beans into longer-lived beans
@Service  // Singleton
public class ReportService {
    private final RequestContext requestContext;  // Request-scoped!
    
    // This won't work as expected - singleton gets ONE instance
    public ReportService(RequestContext requestContext) {
        this.requestContext = requestContext;  // Wrong!
    }
}

// Better: Use Provider or @Lookup
@Service
public class ReportService {
    private final Provider<RequestContext> requestContextProvider;
    
    public ReportService(Provider<RequestContext> requestContextProvider) {
        this.requestContextProvider = requestContextProvider;
    }
    
    public Report generateReport() {
        RequestContext context = requestContextProvider.get();  // Get current request instance
        // Generate report using context
    }
}
```

**When this appears:** Misunderstanding of Spring bean lifecycle, concurrency issues.

**Why it's wrong:** Race conditions, memory leaks, unexpected behavior.

---

## 3. Conditional Beans

### ✅ DO: Use conditional bean registration

```java
// DO: @ConditionalOnProperty
@Configuration
public class CacheConfiguration {
    
    @Bean
    @ConditionalOnProperty(name = "app.cache.enabled", havingValue = "true")
    public CacheManager redisCacheManager(RedisConnectionFactory factory) {
        return RedisCacheManager.builder(factory).build();
    }
    
    @Bean
    @ConditionalOnProperty(name = "app.cache.enabled", havingValue = "false", matchIfMissing = true)
    public CacheManager noOpCacheManager() {
        return new NoOpCacheManager();
    }
}

// DO: @ConditionalOnClass
@Configuration
@ConditionalOnClass(ObjectMapper.class)  // Only if Jackson is on classpath
public class JacksonConfiguration {
    
    @Bean
    public ObjectMapper objectMapper() {
        return new ObjectMapper()
            .registerModule(new JavaTimeModule())
            .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
    }
}

// DO: @ConditionalOnMissingBean
@Configuration
public class SecurityConfiguration {
    
    @Bean
    @ConditionalOnMissingBean  // Only if no other PasswordEncoder bean exists
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

// DO: @Profile for environment-specific beans
@Configuration
@Profile("dev")
public class DevConfiguration {
    
    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .build();
    }
}

@Configuration
@Profile("prod")
public class ProdConfiguration {
    
    @Bean
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(jdbcUrl);
        // Production settings
        return new HikariDataSource(config);
    }
}

// DO: Custom conditional
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Conditional(OnDevelopmentModeCondition.class)
public @interface ConditionalOnDevelopmentMode {
}

public class OnDevelopmentModeCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        String[] activeProfiles = context.getEnvironment().getActiveProfiles();
        return Arrays.asList(activeProfiles).contains("dev") 
            || Arrays.asList(activeProfiles).contains("local");
    }
}

@Configuration
public class DevelopmentConfiguration {
    
    @Bean
    @ConditionalOnDevelopmentMode
    public DevToolsService devTools() {
        return new DevToolsService();
    }
}
```

**When to use:**
- Different implementations for different environments
- Optional features based on properties
- Conditional loading based on classpath
- Auto-configuration libraries

**When NOT to use:** For simple if/else logic in application code.

### ❌ DON'T: Use runtime conditionals for bean creation

```java
// DON'T: Runtime conditional in @Bean method
@Configuration
public class BadConfiguration {
    
    @Value("${app.cache.enabled}")
    private boolean cacheEnabled;
    
    @Bean
    public CacheManager cacheManager() {
        if (cacheEnabled) {  // DON'T - already created bean
            return new RedisCacheManager();
        } else {
            return new NoOpCacheManager();
        }
    }
}

// Better: Use @ConditionalOnProperty
@Bean
@ConditionalOnProperty(name = "app.cache.enabled", havingValue = "true")
public CacheManager redisCacheManager() {
    return new RedisCacheManager();
}

@Bean
@ConditionalOnProperty(name = "app.cache.enabled", havingValue = "false", matchIfMissing = true)
public CacheManager noOpCacheManager() {
    return new NoOpCacheManager();
}

// DON'T: Check profile in code
@Service
public class NotificationService {
    
    @Value("${spring.profiles.active}")
    private String activeProfile;
    
    public void send(Notification notification) {
        if ("prod".equals(activeProfile)) {
            sendRealNotification(notification);
        } else {
            logNotification(notification);
        }
    }
}

// Better: Use profile-specific beans
@Service
@Profile("prod")
public class RealNotificationService implements NotificationService {
    public void send(Notification notification) {
        sendRealNotification(notification);
    }
}

@Service
@Profile("!prod")
public class MockNotificationService implements NotificationService {
    public void send(Notification notification) {
        logNotification(notification);
    }
}
```

**When this appears:** Unfamiliarity with Spring conditional annotations.

**Why it's wrong:** Bean always created, properties not available during bean creation phase.

---

## 4. Configuration Properties

### ✅ DO: Use type-safe configuration

```java
// DO: @ConfigurationProperties with record (Java 16+)
@ConfigurationProperties(prefix = "app.security")
public record SecurityProperties(
    boolean enabled,
    String jwtSecret,
    Duration jwtExpiration,
    List<String> allowedOrigins
) {}

// DO: @ConfigurationProperties with class and validation
@ConfigurationProperties(prefix = "app.database")
@Validated
public class DatabaseProperties {
    
    @NotBlank
    private String url;
    
    @NotBlank
    private String username;
    
    @NotBlank
    private String password;
    
    @Min(1)
    @Max(100)
    private int maxPoolSize = 10;
    
    @NotNull
    private Duration connectionTimeout = Duration.ofSeconds(30);
    
    // Getters and setters
}

// Enable configuration properties
@Configuration
@EnableConfigurationProperties({SecurityProperties.class, DatabaseProperties.class})
public class AppConfiguration {
}

// Usage in service
@Service
@RequiredArgsConstructor
public class SecurityService {
    private final SecurityProperties properties;
    
    public boolean isSecurityEnabled() {
        return properties.enabled();
    }
}

// DO: Nested configuration
@ConfigurationProperties(prefix = "app")
public class ApplicationProperties {
    private final Database database = new Database();
    private final Cache cache = new Cache();
    
    public static class Database {
        private String url;
        private int maxConnections;
        // Getters and setters
    }
    
    public static class Cache {
        private boolean enabled;
        private Duration ttl;
        // Getters and setters
    }
    
    public Database getDatabase() { return database; }
    public Cache getCache() { return cache; }
}

// application.yml
// app:
//   database:
//     url: jdbc:postgresql://localhost/mydb
//     max-connections: 20
//   cache:
//     enabled: true
//     ttl: 1h
```

**When to use:**
- Related configuration properties
- Type conversion needed (Duration, DataSize, etc.)
- Validation required
- Configuration used in multiple places

**When NOT to use:** Single property, simple String value.

### ❌ DON'T: Use @Value for complex configuration

```java
// DON'T: Multiple @Value annotations
@Service
public class DatabaseService {
    
    @Value("${app.database.url}")
    private String url;
    
    @Value("${app.database.username}")
    private String username;
    
    @Value("${app.database.password}")
    private String password;
    
    @Value("${app.database.max-pool-size:10}")
    private int maxPoolSize;
    
    @Value("${app.database.connection-timeout:30}")
    private int connectionTimeout;
    
    // No type safety, no validation, scattered configuration
}

// Better: Use @ConfigurationProperties
@ConfigurationProperties(prefix = "app.database")
public class DatabaseProperties {
    private String url;
    private String username;
    private String password;
    private int maxPoolSize = 10;
    private Duration connectionTimeout = Duration.ofSeconds(30);
    // Getters and setters
}

// DON'T: No validation
@Value("${app.max-users}")
private int maxUsers;  // What if it's negative? What if it's missing?

// Better: @ConfigurationProperties with validation
@ConfigurationProperties(prefix = "app")
@Validated
public class AppProperties {
    @Min(1)
    @Max(10000)
    private int maxUsers = 100;
    // Getter and setter
}

// DON'T: Manual type conversion
@Value("${app.cache.ttl}")
private String ttlString;

public Duration getTtl() {
    return Duration.parse(ttlString);  // Manual conversion
}

// Better: Automatic conversion with @ConfigurationProperties
@ConfigurationProperties(prefix = "app.cache")
public class CacheProperties {
    private Duration ttl;  // Automatically converted from "1h", "30m", "PT1H", etc.
    // Getter and setter
}
```

**When this appears:** Simple applications, unfamiliarity with @ConfigurationProperties.

**Why it's wrong:** No type safety, no validation, harder to test, scattered configuration.

---

## 5. Circular Dependencies

### ✅ DO: Avoid and resolve circular dependencies

```java
// DO: Refactor to eliminate circular dependency
// BEFORE (circular dependency):
// ServiceA → ServiceB → ServiceA

// AFTER: Extract shared functionality
@Service
@RequiredArgsConstructor
public class SharedService {
    private final Repository repository;
    
    public Data loadData(String id) {
        return repository.findById(id);
    }
}

@Service
@RequiredArgsConstructor
public class ServiceA {
    private final SharedService sharedService;
    
    public void processA() {
        Data data = sharedService.loadData("123");
        // Process
    }
}

@Service
@RequiredArgsConstructor
public class ServiceB {
    private final SharedService sharedService;
    
    public void processB() {
        Data data = sharedService.loadData("456");
        // Process
    }
}

// DO: Use events to decouple (if appropriate)
@Service
@RequiredArgsConstructor
public class OrderService {
    private final ApplicationEventPublisher eventPublisher;
    
    public Order createOrder(OrderDto dto) {
        Order order = repository.save(dto.toEntity());
        eventPublisher.publishEvent(new OrderCreatedEvent(order));  // Decouple
        return order;
    }
}

@Service
public class NotificationService {
    
    @EventListener
    public void handleOrderCreated(OrderCreatedEvent event) {
        sendNotification(event.getOrder());  // No direct dependency
    }
}

// DO: Use @Lazy as last resort
@Service
public class ServiceA {
    private final ServiceB serviceB;
    
    public ServiceA(@Lazy ServiceB serviceB) {  // Breaks circular dependency
        this.serviceB = serviceB;
    }
}
```

**When to use:**
- Refactoring: Extract common functionality (preferred)
- Events: For loose coupling
- @Lazy: As last resort when refactoring isn't possible

**When NOT to use:** @Lazy as first solution - it's a code smell.

### ❌ DON'T: Allow circular dependencies

```java
// DON'T: Circular dependency
@Service
@RequiredArgsConstructor
public class UserService {
    private final OrderService orderService;  // UserService → OrderService
    
    public User getUserWithOrders(String userId) {
        User user = repository.findById(userId);
        user.setOrders(orderService.findByUserId(userId));
        return user;
    }
}

@Service
@RequiredArgsConstructor
public class OrderService {
    private final UserService userService;  // OrderService → UserService (CIRCULAR!)
    
    public Order createOrder(OrderDto dto) {
        User user = userService.findById(dto.userId());
        return repository.save(new Order(user, dto.items()));
    }
}
// Spring startup error: circular dependency detected

// Better: Refactor
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    
    public User findById(String userId) {
        return userRepository.findById(userId)
            .orElseThrow(() -> new ResourceNotFoundException("User", userId));
    }
}

@Service
@RequiredArgsConstructor
public class OrderService {
    private final OrderRepository orderRepository;
    private final UserService userService;  // Only OrderService depends on UserService
    
    public Order createOrder(OrderDto dto) {
        User user = userService.findById(dto.userId());
        return orderRepository.save(new Order(user, dto.items()));
    }
    
    public List<Order> findByUserId(String userId) {
        return orderRepository.findByUserId(userId);
    }
}

// UserService no longer depends on OrderService - circular dependency resolved
```

**When this appears:** Poor separation of concerns, tight coupling.

**Why it's wrong:** Application fails to start, indicates design problem.
